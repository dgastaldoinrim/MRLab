import traceback
import sys

class Errors(Exception):
    """
    This class, that inherits Exception in order to become an error handling class, is only a container for the errors that can be raised in MRLab classes.
    """
    pass

    def error_handler(self):
        """
        This function is used to properly handle an ERROR exception, printing all the informations necessary to the users (including the eventual PyVISA
        internal error number and message). After having done this, it prints also the error traceback and stops script execution calling sys.exit() method.
        """
        print(self.code)
        print(self.name)
        print(self.message)
        if hasattr(self, 'error_number'):
            print(self.error_number)
        if hasattr(self, 'error_message'):
            print(self.error_message)
        traceback.print_tb(sys.exc_info()[2])
        sys.exit()

class ManagerErrors(Errors):
    """
    This class, that inherits Errors in order to become an error handling class, is only a container for the errors that can be raised in Manager class.
    """
    pass

class ManagerInitializationError(ManagerErrors):
    """
    This error is raised before manager initialization, if the PyVISA version installed in the Python system used is older than that used to implement
    this version of the package.
    """
    def __init__(self):
        self.code = 'MANAGERERROR1'
        self.name = 'PYVISA_OLDER_THAN_REQUIRED'
        self.message = 'ERROR: During manager initialization phase.\nMaybe PyVISA was not properly installed or you are using a PyVisa version older than 1.8.\nExecution aborted.'

class VoidManagerError(ManagerErrors):
    """
    This error is raised during manager initialization if the initialized manager has no resources available for use even after the resource list
    refreshing.
    """
    def __init__(self):
        self.code = 'MANAGERERROR2'
        self.name = 'VOID_MANAGER_ERROR'
        self.message = 'ERROR: No resources available to manager, even after the refreshing.\nPlease check the links between string = self.instrument.query and computer and try again initialize the manager.\nExecution aborted.'

class InstrumentNotAvailableError(ManagerErrors):
    """
    This error is raised during instrument initialization if the requested resource is not available to the manager for use even after the resource list
    refreshing. The given manager cannot be void in this phase.
    """
    def __init__(self):
        self.code = 'MANAGERERROR3'
        self.name = 'INSTRUMENT_NOT_AVAILABLE_ERROR'
        self.message = 'ERROR: The given adress does not correspond to any instrument available to the manager, even after refreshing.\nPlease check the links between string = self.instrument.query and computer and try again to initialize the manager.\nExecution aborted'

class CryostatErrors(Errors):
    """
    This class, that inherits Errors in order to become an error handling class, is used in order to catch all the exceptions generated by the Cryostat class.
    """
    pass

class CryostatWrongReadTerminator(CryostatErrors):
    """
    This error will be rised when an incorrect read terminator string is set during Cryostat instruments initialization.
    """
    def __init__(self, terminator):
        self.code = 'CRYOSTATERROR1'
        self.name = 'WRONG_READ_TERMINATOR_STRING_SET'
        self.message = 'ERROR: {0:G} is not a valid read terminator string and will not be recognized by the instrument.\nAvailable string are "CR" (\\r) and "CRLF" (\\r\\n combination).'.format(terminator)

class CryostatWrongWriteTerminator(CryostatErrors):
    """
        This error will be rised when an incorrect write terminator string is set during Cryostat instruments initialization.
    """
    def __init__(self, terminator):
        self.code = 'CRYOSTATERROR2'
        self.name = 'WRONG_WRITE_TERMINATOR_STRING_SET'
        self.message = 'ERROR: {0:G} is not a valid write terminator string and will not be recognized by the instrument.\nAvailable string are "CR" (\\r) and "CRLF" (\\r\\n combination).'.format(terminator)

class CryostatIncorrectUnlockKey(CryostatErrors):
    """
    This error will be rised when an incorrect unlock key (i.e. a negative number or a positive number greater than 9999) is issued to any of the instruments
    that make up the cryostat.
    """
    def __init__(self, unlock_key):
        self.code = 'CRYOSTATERROR1'
        self.name = 'INCORRECT_UNLOCK_KEY_SENT'
        self.message = 'ERROR: {0:G} is not a valid unlock key for the unlock system commands function. Valid times must be numbers greater or equal to 0 and less or equal to 9999.'.format(unlock_key)

class CryostatIncorrectDelayTime(CryostatErrors):
    """
    This error will be rised when an incorrect delay time (i.e. a negative number or a wait time larger than 32767) is issued to any of the instruments that make up the cryostat.
    """
    def __init__(self, delay_time):
        self.code = 'CRYOSTATERROR2'
        self.name = 'INCORRECT_DELAY_TIME_SENT'
        self.message = 'ERROR: {0:G} is not a valid delay time for the set delay function. Valid times must be equal to 0 or positive numbers.'.format(delay_time)
        
class CryostatIncorrectISOBUSAdress(CryostatErrors):
    """
    This error will be rised when any Oxford Instrument stops responding to sent commands (i.e. when the reply to a query command contains a '?' string).
    """
    def __init__(self, adress):
        self.code = 'CRYOSTATERROR3'
        self.name = 'INCORRECT_ISOBUS_ADRESS_SENT'
        self.message = 'ERROR: {0:G} is not a valid ISOBUS adress. Valid times must be greater than or equal to 0 or and less than or equal to 8.'.format(adress)

class LevelMeterErrors(CryostatErrors):
    """
    This class, that inherits CryostatErrors in order to become an error handling class, is only a container for the errors that can be raised only in the
    Oxford IML class that are not general enough to be treated as Cryostat's class error.
    """
    pass

class LMNotResponding(LevelMeterErrors):
    """
    This error will be rised when Intelligent Level Meter stops responding to sent commands (i.e. when the reply to a query command contains a '?' string).
    """
    def __init__(self):
        self.code = 'ILMERROR1'
        self.name = 'ILM_STOPS_RESPONDING'
        self.message = 'ERROR: The ILM reply to a query contains a "?" string or ILM stop responding.'

class LMChannelNotUsed(LevelMeterErrors):
    """
    This error will be raised when the user passes to a function a wrong channel number (i.e a negative or zero value or a value greater than 3, that is the
    maximum number of channels available for Oxford Level Meter series).
    """
    def __init__(self, channel):
        self.code = 'ILMERROR2'
        self.name = 'CHANNEL_NOT_IN_USE'
        self.message = 'ERROR: Channel number {%s} is not in use.'.format(channel)

class LMErrorOnChannel(LevelMeterErrors):
    """
    This error will be raised when the user passes to a function a wrong channel number (i.e a negative or zero value or a value greater than 3, that is the
    maximum number of channels available for Oxford Level Meter series).
    """
    def __init__(self):
        self.code = 'ILMERROR3'
        self.name = 'ERROR_ON_CHANNEL'
        self.message = 'ERROR: Channel number {%s} is not reading correctly or reporting an error.'

class Low_LHe_level(LevelMeterErrors):
    """
    This error will be raised when the liquid helium level measured with the Cryostat probe is low (threshold is set to 20%.).
    """
    def __init__(self):
        self.code = 'ILMERROR4'
        self.name = 'LOW_LIQUID_HELIUM_LEVEL'
        self.message = 'ERROR: Liquid Helium level is below the 20% threshold. Stopping both magnet and measurement in order to prevent damages.'

class Low_LN2_level(LevelMeterErrors):
    """
    This error will be raised when the liquid nitrogen level measured with the Cryostat probe is low (threshold is set to 10%.).
    """
    def __init__(self):
        self.code = 'ILMERROR5'
        self.name = 'LOW_LIQUID_NITROGEN_LEVEL'
        self.message = 'ERROR: Liquid Nitrogen level is below the 10% threshold. Please refill now in order to avoid helium losses.'

class LMNotHeliumChannel(LevelMeterErrors):
    """
    This error will be raised when the channel selected by the user in the command is not an Helium measurement channel.
    """
    def __init__(self,channel):
        self.code = 'ILMERROR6'
        self.name = 'NOT_AN_HELIUM_CHANNEL'
        self.message = 'ERROR: Channel number {%s} is not an Helium level measurement channel.'.format(channel)

class LMIncorrectChannelNumber(LevelMeterErrors):
    """
    This error will be raised when the channel selected by the user in the command is not an Helium measurement channel.
    """
    def __init__(self,channel):
        self.code = 'ILMERROR7'
        self.name = 'INCORRECT_CHANNEL_NUMBER'
        self.message = 'ERROR: {%s} is not a correct channel number (must be between 1 and 3).'.format(channel)
 
class PowerSupplyErrors(Errors):
    """
    This class, that inherits CryostatErrors in order to become an error handling class, is only a container for the errors that can be raised only in the
    Oxford IPS class that are not general enough to be treated as Cryostat's class error.
    """
    pass    
        
class PSNotResponding(PowerSupplyErrors):
    """
    This error will be rised when Intelligent Power Supply stops responding to sent commands (i.e. when the reply to a query command contains a '?' string).
    """
    def __init__(self):
        self.code = 'IPSERROR1'
        self.name = 'IPS_STOPS_RESPONDING'
        self.message = 'ERROR: The IPS reply contains a "?" string or IPS stop responding.'

class PSWrongOutputCurrent(PowerSupplyErrors):
    """
    This error will be rised when user supplies to the set current function a current value outside the available range (-98.46 A to +98.46 A).
    """
    def __init__(self, current):
        self.code = 'IPSERROR2'
        self.name = 'IPS_WRONG_OUTPUT_CURRENT'
        self.message = 'ERROR: Supplied current value ({0:G} A) is out of the available range (-98.46 A to +98.46 A).'.format(current)

class PSWrongOutputField(PowerSupplyErrors):
    """
    This error will be rised when user supplies to the set field function a field value outside the available range (-7 T to +7 T).
    """
    def __init__(self, field):
        self.code = 'IPSERROR3'
        self.name = 'IPS_WRONG_OUTPUT_CURRENT'
        self.message = 'ERROR: Supplied field value ({0:G} T) is out of the available range (-7 T to +7 T).'.format(field)

class PSWrongCurrentSweepRate(PowerSupplyErrors):
    """
    This error will be rised when user supplies to the set current sweep rate function a rate value outside the available range (up to 16.88 A per minute).
    """
    def __init__(self, current):
        self.code = 'IPSERROR4'
        self.name = 'IPS_WRONG_CURRENT_SWEEP_RATE'
        self.message = 'ERROR: Supplied current sweep rate ({0:G} A per minute) is out of the available range (up to 16.88 A per minute).'

class PSWrongFieldSweepRate(PowerSupplyErrors):
    """
    This error will be rised when user supplies to the set field sweep rate function a rate value outside the available range (up to 1.2 T per minute).
    """
    def __init__(self, current):
        self.code = 'IPSERROR4'
        self.name = 'IPS_WRONG_FIELD_SWEEP_RATE'
        self.message = 'ERROR: Supplied field sweep rate ({0:G} T per minute) is out of the available range (up to 1.2 T per minute).'
        
class TemperatureControllerErrors(CryostatErrors):
    """
    This class, that inherits CryostatErrors in order to become an error handling class, is only a container for the errors that can be raised only in the
    Oxford ITC class that are not general enough to be treated as Cryostat's class error.
    """
    pass

class TCNotResponding(TemperatureControllerErrors):
    """
    This error will be rised when Intelligent Temperature Controller stops responding to sent commands (i.e. when the reply to a query command contains a '?' string).
    """
    def __init__(self):
        self.code = 'ITCERROR1'
        self.name = 'ITC_STOPS_RESPONDING'
        self.message = 'ERROR: The ITC reply contains a "?" string or ITC stop responding.'

class TCPOutOfRange(TemperatureControllerErrors):
    """
    This error will be rised when desired P control term for the Intelligent Temperature Controller is out of the acceptable range (5 to 50 K/°C).
    """
    def __init__(self, P):
        self.code = 'ITCERROR2'
        self.name = 'ITC_P_OUT_OF_RANGE'
        self.message = 'ERROR: The given value ({0:G}) for the P (PROPORTIONAL BAND) term is out of the acceptable range (from 5 to 50 K/°C).'.format(P)

class TCIOutOfRange(TemperatureControllerErrors):
    """
    This error will be rised when desired I control term for the Intelligent Temperature Controller is out of the acceptable range (from 0 to 140 minutes).
    """
    def __init__(self, I):
        self.code = 'ITCERROR3'
        self.name = 'ITC_I_OUT_OF_RANGE'
        self.message = 'ERROR: The given value ({0:G}) for the I (INTEGRAL ACTION TIME) term is out of the acceptable range (from 0 to 140 minutes).'.format(I)

class TCDOutOfRange(TemperatureControllerErrors):
    """
    This error will be rised when desired D control term for the Intelligent Temperature Controller is out of the acceptable range (from 0 to 273 minutes).
    """
    def __init__(self, D):
        self.code = 'ITCERROR4'
        self.name = 'ITC_D_OUT_OF_RANGE'
        self.message = 'ERROR: The given value ({0:G}) for the D (DERIVATIVE ACTION TIME) term is out of the acceptable range (from 0 to 273 minutes).'.format(D)

class TCWrongControllingSensorNumber(TemperatureControllerErrors):
    """
    This error will be rised when the user tries to set the heater controlling sensor to a number outside the available sensor number range (integers from 1 to 3).
    """
    def __init__(self, sensor_number):
        self.code = 'ITCERROR5'
        self.name = 'ITC_WRONG_SENSOR_NUMBER'
        self.message = 'ERROR: The given value ({0:G}) for the controlling sensor number is out of the acceptable range (integers from 1 to 3).'.format(channel_number)

class TCWrongPercentage(TemperatureControllerErrors):
    """
    This error will be rised when the user tries to set the needle valve or heater output percentage to a value outside the acceptable range.
    """
    def __init__(self, percentage):
        self.code = 'ITCERROR6'
        self.name = 'ITC_WRONG_PERCENTAGE'
        self.message = 'ERROR: The given value ({0:G}) for the needle valve or heater output percentage is out of range.'.format(percentage)

class TCWrongMaxOutputVoltage(TemperatureControllerErrors):
    """
    This error will be rised when the user tries to set the needle valve or heater output percentage to a value outside the acceptable range (from 0 to 40 V).
    """
    def __init__(self, max_voltage):
        self.code = 'ITCERROR7'
        self.name = 'ITC_WRONG_MAXIMUM_OUTPUT_VOLTAGE'
        self.message = 'ERROR: The given value ({0:G}) for the heater maximum voltage is out of range (from 0 to 40 V).'.format(max_voltage)

class TCWrongSetPoint(TemperatureControllerErrors):
    """
    This error will be rised when the user tries to set the needle valve or heater output percentage to a value outside the acceptable range (from 0 to 420 K).
    """
    def __init__(self, set_point):
        self.code = 'ITCERROR8'
        self.name = 'ITC_WRONG_SET_POINT'
        self.message = 'ERROR: The given value ({0:G}) for the temperature set point is out of range (from 0 to 420 K).'.format(set_point)

class TCWrongSweepStartingPoint(TemperatureControllerErrors):
    """
    This error will be rised when the user tries to set the needle valve or heater output percentage to a value outside the acceptable range (from 1 to 32).
    """
    def __init__(self, starting_point):
        self.code = 'ITCERROR9'
        self.name = 'ITC_WRONG_SWEEP_STARTING_POINT'
        self.message = 'ERROR: The given value ({0:G}) for the sweep starting point is out of range (from 1 to 32).'.format(set_point)

class InstrumentsErrors(Errors):
    """
    This class, that inherits Errors in order to become an error handling class, is only a container for the errors that can be raised in the Instruments
        class.
    """
    pass

class InvalidManagerError(InstrumentsErrors):
    """
    This error is raised when the attached manager istance is not a valid one (maybe because it was not istantiated before the call of the
        Instruments.__init__ function).
    """
    def __init__(self):
        self.code = 'INSTRUMENTERROR1'
        self.name = 'INVALID_MANAGER_SESSION_ERROR'
        self.message = 'ERROR: The given manager session is invalid.\nExecution aborted.'

class InvalidReadTerminatorError(InstrumentsErrors):
    """
    This error is raised when the user gives an incorrect read terminator string to the instrument initialization function.
    """
    def __init__(self):
        self.code = 'INSTRUMENTERROR2'
        self.name = 'INVALID_READ_TERMINATOR_ERROR'
        self.message = 'ERROR: The read terminator string given for this instrument is not correct.\nExecution aborted.'

class InvalidWriteTerminatorError(InstrumentsErrors):
    """
    This error is raised when the user gives an incorrect write terminator string to the instrument initialization function.
    """
    def __init__(self):
        self.code = 'INSTRUMENTERROR3'
        self.name = 'INVALID_WRITE_TERMINATOR_ERROR'
        self.message = 'ERROR: The write terminator string given for this instrument is not correct.\nExecution aborted.'

class InvalidTypeDictionaryKeyError(InstrumentsErrors):
    """
    This error will be raised when the user supply a key string not present into the dictionary originatet by the type_dictionary function.
    """
    def __init__(self):
        self.code = 'INSTRUMENTERROR4'
        self.name = 'INVALID_TYPES_DICTIONARY_KEY_ERROR'
        self.message = 'ERROR: The string given as key is not in the type_dictionary keys.\nSo, controller does not know what buffer has to attach to the output buffer.\nExecution aborted.'
        
class IncorrectInstrumentError(InstrumentsErrors):
    """
    This error will be raised by classes that inherit their methods from this class in order to deal with the fact that a distracted user can associate a
        method that must be used with a particular instrument with another model of instrument.
    """
    def __init__(self):
        self.code = 'INSTRUMENTERROR5'
        self.name = 'INCORRECT_INSTRUMENT_ERROR'
        self.message = 'ERROR: You have supplied an Instrument class method to an incorrect instrument.\nExecution aborted.' 

class ReportInstrumentInternalError(InstrumentsErrors):
    """
    This error will be raised by classes that inherit their methods from this class in order to deal with the fact that the adressed instrument can in
        any moment report an error. The exception handling will take into account also the showing of informations given by the adressed instrument.
    
    Initialization parameters:
        - error_number = PyVISA internal error number.
        - error_message = PyVISA internal error message.
    """
    def __init__(self, error_number, error_message):
        self.code = 'INSTRUMENTERROR6'
        self.name = 'INSTRUMENT_INTERNAL_ERROR'
        self.message = 'ERROR: The instruments reports the following PyVISA error.\nExecution will stop immediately after the report.'
        self.error_number = error_number
        self.error_message = error_message

class Lakeshore340Errors(Errors):
    """
    This class, that inherits Errors in order to become an error handling class, is only a container for the errors that can be raised only in the
        Keithley2400 class and are not general enough to be treated as Instruments' class error.
    """
    pass

class LS340NotResponding(Lakeshore340Errors):
    """
    This error will be rised by Lakeshore 340 Temperature Controller when it doesn't respond correctly to a query or the response doesn't correspond to what
        the users set with a corresponding set function.
    """
    def __init__(self):
        self.code = 'LS340ERROR1'
        self.name = 'LAKESHORE_340_NOT_RESPONDING'
        self.message = 'ERROR: Lakeshore 340 Temperature controller stops responding.'

class LS340LS340InternalProgrammingError(Lakeshore340Errors):
    """
    This error will be rised by Lakeshore 340 Temperature Controller when it doesn't respond correctly to a query or the response doesn't correspond to what
        the users set with a corresponding set function.
    """
    def __init__(self, error_number):
        self.code = 'LS340ERROR2'
        self.name = 'LAKESHORE_340_INTERNAL_PROGRAMMING_ERROR'
        if error_number == 1:
            self.message = 'ERROR: Lakeshore 340 Temperature controller reports too many Call commands in the internal program.'
        elif error_number == 2:
            self.message = 'ERROR: Lakeshore 340 Temperature controller reports too many Repeat commands in the internal program.'
        elif error_number == 3:
            self.message = 'ERROR: Lakeshore 340 Temperature controller reports too many End Repeat commands in the internal program.'
        elif error_number == 4:
            self.message = 'ERROR: Lakeshore 340 Temperature controller reports Control channel setpoint is not a temperature.'

class Keithley2400Errors(Errors):
    """
    This class, that inherits Errors in order to become an error handling class, is only a container for the errors that can be raised only in the
        Keithley2400 class and are not general enough to be treated as Instruments' class error.
    """
    pass

class Keithley2400TooManyArms(Keithley2400Errors):
    """
    This error will be raised by the Keithley_2400 class while configuring the instrument arm layer, if the given arm count is more than 2500 (maximum
        memory buffer size).
    """
    def __init__(self):
        self.code = 'KEITHLEY2400ERROR1'
        self.name = 'TOO_MANY_ARMS'
        self.message = 'ERROR: Too many arm counts given.\nMaximum arm count number is 2500.\nExecution aborted.'

class Keithley2400NegativeArmCountError(Keithley2400Errors):
    """
    This error will be raised by the Keithley_2400 class while configuring the instrument arm layer, if the given arm count is 0 or negative.
    """
    def __init__(self):
        self.code = 'KEITHLEY2400ERROR2'
        self.name = 'ARM_COUNT_MUST_BE_POSITIVE'
        self.message = 'ERROR: 0 or negative arm count given.\nMinimum count number is 1.\nExecution aborted.'

class Keithley2400TooManyTriggers(Keithley2400Errors):
    """
    This error will be raised by the Keithley_2400 class while configuring the instrument trigger layer, if the product of the given trigger count with
        the configured arm count is greater than 2500 (maximum memory buffer size).
    """
    def __init__(self):
        self.code = 'KEITHLEY2400ERROR3'
        self.name = 'TOO_MANY_TRIGGERS'
        self.message = 'ERROR: Too many trigger counts given.\nMaximum number is the result of the integer division between 2500 and the configured arm layer count.\nExecution aborted.'

class Keithley2400NegativeTriggerCountError(Keithley2400Errors):
    """
    This error will be raised by the Keithley_2400 class while configuring the instrument trigger layer, if the given trigger count is 0 or negative.
    """
    def __init__(self):
        self.code = 'KEITHLEY2400ERROR4'
        self.name = 'TRIGGER_COUNT_MUST_BE_POSITIVE'
        self.message = 'ERROR: 0 or negative triggercount given.\nMinimum count number is 1.\nExecution aborted.'
        
class Keithley6517AErrors(Errors):
    """
    This class, that inherits Errors in order to become an error handling class, is only a container for the errors that can be raised only in the
    Keithley6517A class and are not general enough to be handled by InstrumentsErrors class.
    """
    pass

class Keithley6517AIncorrectSourceValueError(Keithley6517AErrors):
    """
    This error will be raised in any case in which the users gives to the instrument a source value greater than 1 kV in modulus.
    """
    def __init__(self):
        self.code = 'KEITHLEY6517AERROR1'
        self.name = 'INVALID_SOURCE_VALUE'
        self.message = 'ERROR: Voltage source value must lie in the range -1 kV - +1 kV.\nExecution aborted.'
        
class AnalysisErrors(Errors):
    """
    This class, that inherits Errors in order to become an error handling class, is only a container for the errors that can be raised in Analysis class.
    """
    pass

class VoidAnalysisError(Errors):
    """
    This errors will be raised in the Analysis class if it's impossible to find files that matches the pattern given in the __init__ function.
    """
    def __init__(self):
        self.code = 'ANALYSISERROR1'
        self.name = 'NO_FILENAMES_TO_ANALYZE'
        self.message = 'ERROR: In the given directory no filenames match the given sample name and mode.\nExecution aborted.'
        
class InvalidFilenameError(Errors):
    """
    This errors will be raised in the Analysis class if it's impossible to split filename in the format required to produce long and short keys, that is 
        sample-name_measured-characteristics_temperature_field_source-mode_measurement-mode.
    """
    def __init__(self):
        self.code = 'ANALYSISERROR2'
        self.name = 'INVALID_FILENAME'
        self.message = 'ERROR: The given filename could not be splitted in the format needed for the analysis keys creation (sample-name_measured-characteristics_temperature_field_source-mode_measurement-mode).\nExecution aborted.'